%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ast.h"    // Ensure this is included for Value_Node etc. if used by yylval directly (not in this case)
#include "parser.h" // Include the parser header generated by Bison (defines tokens, YYSTYPE, yylval)

// External variables for line/column tracking, used by yyerror
// Ensure these are declared 'extern int line_num;' in parser.y if not defined there.
// Or, define them here and ensure parser.y can access them (e.g. if parser.y includes a header that declares them).
// For simplicity, assume they are defined here and parser.y's yyerror can see them.
int line_num = 1;
int col_num = 1;

/* Helper to update column number based on yytext. Call for every token. */
static void update_pos() {
    int i;
    for (i = 0; yytext[i] != '\0'; i++) {
        if (yytext[i] == '\n') {
            line_num++;
            col_num = 1;
        } else if (yytext[i] == '\t') {
            col_num += 4; // Or some other tab stop value
        }
        else {
            col_num++;
        }
    }
}

/* * process_string: Removes the surrounding quotes from a string literal token.
 * IMPORTANT: It also needs to handle escape sequences like \n, \", \\, etc.
 * The current version only strips quotes. A full implementation is more complex.
 * For now, focusing on memory safety with quote stripping.
 */
char* process_string(const char* text_with_quotes) {
    size_t len = strlen(text_with_quotes);
    char* processed_str;

    if (len < 2) { // Should not happen for valid STRING token like ""
        processed_str = strdup(""); // Return empty string for safety
        if (!processed_str) {
            fprintf(stderr, "Lexer Error: Memory allocation failed for empty string.\n");
            exit(EXIT_FAILURE);
        }
        return processed_str;
    }

    // Allocate memory for the string content (length - 2) plus null terminator (1)
    // So, len - 2 + 1 = len - 1
    processed_str = (char*)malloc(len - 1);
    if (!processed_str) {
        fprintf(stderr, "Lexer Error: Memory allocation failed in process_string.\n");
        exit(EXIT_FAILURE);
    }

    // Copy the content, excluding the first and last quote
    strncpy(processed_str, text_with_quotes + 1, len - 2);
    processed_str[len - 2] = '\0'; // Null-terminate

    // TODO: Implement unescaping of sequences like \", \\, \n, \t, \uXXXX here.
    // This would involve iterating through processed_str, interpreting escapes,
    // and potentially reallocating if the unescaped string is shorter.
    // For example, "\\n" (2 chars) becomes '\n' (1 char).

    return processed_str;
}

%}

%option noyywrap
%option yylineno 
/* yylineno provides line numbers automatically, but col_num still needs manual tracking if precise.
   If yylineno is used, 'line_num = yylineno;' can be used in update_pos or per rule.
   For now, keeping manual line_num for consistency with col_num.
*/


%%

"{"         { update_pos(); return '{'; }
"}"         { update_pos(); return '}'; }
"["         { update_pos(); return '['; }
"]"         { update_pos(); return ']'; }
":"         { update_pos(); return ':'; }
","         { update_pos(); return ','; }

\"([^\\\"]|\\.)*\"  { /* Simplified string regex, allows any escaped char. \uXXXX needs more. */
                    /* Original: \"([^\\\"]|\\[\"\\/bfnrt]|\\u[0-9a-fA-F]{4})*\" */
    update_pos();
    yylval.string_val = process_string(yytext); // process_string MUST return heap memory
    return STRING;
}

 /* Number: integer, optional fraction, optional exponent */
-?[0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)? {
    update_pos();
    yylval.number_val = atof(yytext);
    return NUMBER;
}

"true"      { update_pos(); yylval.boolean_val = 1; return BOOLEAN; }
"false"     { update_pos(); yylval.boolean_val = 0; return BOOLEAN; }
"null"      { update_pos(); return NUL; }

[ \t]+      { update_pos(); /* Skip whitespace */ }
[\n\r]+     { update_pos(); /* Skip newlines, update_pos handles line_num */ }

.           { 
    update_pos();
    fprintf(stderr, "Lexer Error: Unexpected character '%s' (ASCII: %d) at line %d, col %d\n", 
            yytext, (int)yytext[0], line_num, col_num);
    exit(EXIT_FAILURE); 
}

%%

// Function to be called by yyparse if it needs to initiate parsing.
// int main(int argc, char** argv) { // Example main for lexer testing
//     if (argc > 1) yyin = fopen(argv[1], "r");
//     yylex();
//     return 0;
// }

// No need for yywrap function if %option noyywrap is used.

