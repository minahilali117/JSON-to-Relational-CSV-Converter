%{
    /**
     * scanner.l - JSON lexer for json2relcsv using Flex
     */
    
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include "parser.h"  // Generated by Yacc/Bison
    
    // Tracking line and column numbers for error reporting
    int line_num = 1;
    int col_num = 1;
    int prev_col = 1;
    char string_buffer[65536];  // Buffer for string literals
    int string_buf_ptr = 0;
    
    // Function to update column position
    void update_col() {
        col_num += yyleng;
    }
    
    // Function for handling newlines
    void handle_newline() {
        int i;
        for (i = 0; i < yyleng; i++) {
            if (yytext[i] == '\n') {
                line_num++;
                prev_col = col_num;
                col_num = 1;
            } else {
                col_num++;
            }
        }
    }
    
    // Function to add character to string buffer
    void add_to_string(char c) {
        if (string_buf_ptr >= sizeof(string_buffer) - 1) {
            fprintf(stderr, "Error: String buffer overflow at line %d, column %d\n", line_num, col_num);
            exit(EXIT_FAILURE);
        }
        string_buffer[string_buf_ptr++] = c;
    }
    
    %}
    
    %option noyywrap
    %option nounput
    %option noinput
    
    /* Exclusive start condition for string parsing */
    %x STRING
    
    %%
    
    [ \t]+         { update_col(); } /* Ignore whitespace but update column */
    [\n\r]         { handle_newline(); } /* Count newlines for error tracking */
    
    "{"            { update_col(); return '{'; }
    "}"            { update_col(); return '}'; }
    "["            { update_col(); return '['; }
    "]"            { update_col(); return ']'; }
    ":"            { update_col(); return ':'; }
    ","            { update_col(); return ','; }
    
    "true"         { 
                     update_col(); 
                     yylval.boolean_val = 1; 
                     return BOOLEAN; 
                   }
    "false"        { 
                     update_col(); 
                     yylval.boolean_val = 0; 
                     return BOOLEAN; 
                   }
    "null"         { update_col(); return NUL; }
    
    -?[0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)? { 
                     update_col(); 
                     yylval.number_val = atof(yytext); 
                     return NUMBER; 
                   }
    
    \"            { 
                     update_col();
                     string_buf_ptr = 0;
                     BEGIN(STRING);
                   }
    
    <STRING>\"     { 
                     BEGIN(INITIAL);
                     string_buffer[string_buf_ptr] = '\0';
                     yylval.string_val = strdup(string_buffer);
                     if (!yylval.string_val) {
                         fprintf(stderr, "Error: Memory allocation failed for string at line %d, column %d\n", 
                                 line_num, col_num);
                         exit(EXIT_FAILURE);
                     }
                     update_col();
                     return STRING;
                   }
    
    <STRING>\\\"   { add_to_string('"'); update_col(); }
    <STRING>\\\\   { add_to_string('\\'); update_col(); }
    <STRING>\\/    { add_to_string('/'); update_col(); }
    <STRING>\\b    { add_to_string('\b'); update_col(); }
    <STRING>\\f    { add_to_string('\f'); update_col(); }
    <STRING>\\n    { add_to_string('\n'); update_col(); }
    <STRING>\\r    { add_to_string('\r'); update_col(); }
    <STRING>\\t    { add_to_string('\t'); update_col(); }
    <STRING>\\u[0-9a-fA-F]{4} {
                     /* Convert Unicode escape sequence */
                     int code;
                     sscanf(yytext + 2, "%x", &code);
                     
                     /* For simplicity, only handle basic ASCII and some common chars */
                     if (code < 128) {
                         add_to_string((char)code);
                     } else {
                         /* For non-ASCII, store simple replacement */
                         add_to_string('?');
                     }
                     update_col();
                   }
    
    <STRING>[^\\"]+  { 
                       /* Copy normal string content */
                       char* yptr = yytext;
                       while (*yptr) {
                           add_to_string(*yptr++);
                       }
                       update_col();
                     }
    
    <STRING>\\     { 
                     /* Invalid escape */
                     fprintf(stderr, "Error: Invalid escape sequence at line %d, column %d\n", 
                            line_num, col_num);
                     exit(EXIT_FAILURE);
                   }
    
    <STRING><<EOF>> { 
                      fprintf(stderr, "Error: Unterminated string at line %d, column %d\n", 
                             line_num, col_num);
                      exit(EXIT_FAILURE);
                    }
    
    <STRING>.      { 
                     /* Unexpected character in string */
                     fprintf(stderr, "Error: Invalid character in string at line %d, column %d: '%c'\n", 
                            line_num, col_num, yytext[0]);
                     exit(EXIT_FAILURE);
                   }
    
    .              { 
                     /* Invalid token */
                     fprintf(stderr, "Error: Invalid token at line %d, column %d: '%c'\n", 
                            line_num, col_num, yytext[0]);
                     exit(EXIT_FAILURE);
                   }
    
    %%